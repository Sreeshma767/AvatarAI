version: '3.8'  # Docker Compose file format version

services:
  wordpress:  # WordPress service
    image: wordpress:latest
    ports:
      - "8080:80"  # Map port 80 of the container to port 8080 of the host
    environment:
      WORDPRESS_DB_HOST: db:3306  # Database host
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
    depends_on:
      - db  # Ensures the db service starts first

  db:  # MySQL service
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress


âœ… 1. Basic Docker Compose Template (Starter)
version: "3.9"

services:
  app:
    image: nginx:latest
    ports:
      - "8080:80"
    volumes:
      - .:/usr/share/nginx/html

âœ… 2. Docker Compose for Java Spring Boot + MySQL
4
version: "3.9"

services:
  app:
    build: .
    container_name: spring-app
    ports:
      - "8080:8080"
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/testdb
      SPRING_DATASOURCE_USERNAME: root
      SPRING_DATASOURCE_PASSWORD: password
    depends_on:
      - mysql

  mysql:
    image: mysql:8
    container_name: mysql-db
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: testdb
    volumes:
      - mysql-data:/var/lib/mysql
    ports:
      - "3306:3306"

volumes:
  mysql-data:

âœ… 3. Docker Compose for Node.js + MongoDB
version: "3.9"

services:
  api:
    build: .
    container_name: node-api
    ports:
      - "5000:5000"
    environment:
      MONGO_URL: mongodb://mongo:27017/mydb
    depends_on:
      - mongo

  mongo:
    image: mongo:6
    container_name: mongodb
    ports:
      - "27017:27017"
    volumes:
      - mongo-data:/data/db

volumes:
  mongo-data:

âœ… 4. Docker Compose for Backend + Nginx Reverse Proxy
version: "3.9"

services:
  backend:
    build: ./backend
    container_name: backend-service
    ports:
      - "3000:3000"

  nginx:
    image: nginx:latest
    container_name: nginx-proxy
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - backend

âœ… 5. Microservice Setup (API Gateway + 2 Services + DB)
version: "3.9"

services:
  gateway:
    build: ./gateway
    ports:
      - "8080:8080"
    depends_on:
      - user
      - product

  user:
    build: ./user-service
    ports:
      - "8081:8081"

  product:
    build: ./product-service
    ports:
      - "8082:8082"
    depends_on:
      - db

  db:
    image: postgres:15
    environment:
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: admin
      POSTGRES_DB: shopdb
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  pgdata:

ðŸ’¡ Final: Explanation of Compose Keywords (Super Important)
Keyword	Meaning
services	All containers to run
image	Pull from Docker Hub
build	Build Dockerfile from local folder
container_name	Custom container name
ports	host:container port mapping
volumes	Data persist or mount local folder
environment	Env variables passed to container
depends_on	Start order of containers
networks	Custom network configuration
restart: always	Auto restart on crash
command	Override container start comma



PART 1 â€“ Docker-compose with two servers (nginx + tomee)
Step 1 â€“ Run two containers using docker run (simple way)

In PowerShell, run:

docker run -d -p 8010:80 nginx
docker run -d -p 8020:8080 tomee

Step 2 â€“ Check in browser

Open:

http://localhost:8010
 â†’ Nginx default page

http://localhost:8020
 â†’ Tomee page (if app is there)

This proves two containers can run simultaneously on different ports.

Step 3 â€“ Put same setup into a docker-compose file

Make a folder:

mkdir comp-1-server
cd comp-1-server


Create docker-compose.yml and put:

services:
  web:
    image: nginx
    ports:
      - "8060:80"

  db:
    image: tomee
    ports:
      - "8050:8080"

Step 4 â€“ Start using docker-compose

From inside comp-1-server folder:

docker-compose up -d


(or)

docker compose up -d


Docker will create a network (comp-1-server_default) and start both containers.

Step 5 â€“ Open in browser

http://localhost:8060
 â†’ nginx page

http://localhost:8050
 â†’ tomee page

PART 2 â€“ WordPress + MySQL using docker-compose
Step 1 â€“ Create folder and file

In PowerShell:

cd C:\Users\NekshaSrinivas\SE-1
mkdir mysql
cd mysql
notepad docker-compose.yml


Inside docker-compose.yml, write:

services:
  wordpress:        # WordPress service
    image: wordpress:latest
    ports:
      - "9080:80"   # host 9080 -> container 80
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
    depends_on:
      - db          # start DB first

  db:               # MySQL service
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress

Step 2 â€“ Start the stack

Inside:

C:\Users\NekshaSrinivas\SE-1\mysql


Run:

docker-compose up -d


You will see:

network mysql_default created

containers mysql-db-1 and mysql-wordpress-1 started

Step 3 â€“ Open WordPress site

In browser, open:

http://localhost:9080


Steps on screen:

Select language

Fill details (site title, admin username, password, email)

Click Install WordPress â†’ success message

Log in with created credentials â†’ Dashboard page appears

PART 3 â€“ Custom Flask app + MySQL using docker-compose
Step 1 â€“ Create new project folder

In PowerShell:

cd C:\Users\NekshaSrinivas\SE-1
mkdir custom_flask
cd custom_flask


You will create three files here:

app.py â€“ Flask application code

Dockerfile â€“ how to build the Flask image

docker-compose.yml â€“ runs Flask + MySQL together

Step 2 â€“ Write app.py
notepad app.py


Write:

from flask import Flask

app = Flask(name)

@app.route("/")
def home():
    return "Hello from 24BD5A0503 - NEKSHASRINIVAS"

if name == "main":
    app.run(host="0.0.0.0", port=5000)

Step 3 â€“ Write Dockerfile

(Use notepad Dockerfile and rename if required.)

Write:

FROM python:3.10-slim

WORKDIR /app

COPY app.py /app

RUN pip install flask

CMD ["python", "app.py"]


(We are not yet using MySQL from code, DB is just running alongside.)

Step 4 â€“ Write docker-compose.yml
notepad docker-compose.yml


Write:

version: "3.9"

services:
  web:
    build: .
    ports:
      - "5000:5000"
    depends_on:
      - db

  db:
    image: mysql:8.0
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: mydb
    ports:
      - "3306:3306"   # change to 3307:3306 if already used

Step 5 â€“ Build and run with docker compose

From inside:

C:\Users\NekshaSrinivas\SE-1\custom_flask


Run:

docker compose up --build


(--build forces Docker to build the web image using the Dockerfile.)

If port 3306 is already in use, change:

3306:3306 â†’ 3307:3306


If you want to run in background:

docker compose up --build -d

Step 6 â€“ View your custom Flask page

Open:

http://localhost:5000


You should see:

Hello from 24BD5A0503 - NEKSHASRINIVAS



5. Docker CLI Commands
Installing Docker and Setting up Nginx inside Ubuntu Container

Step 1: Check Docker installation & Pull Ubuntu image
Check that Docker is installed and running:
docker --version

Pull the latest Ubuntu image from Docker Hub:
docker pull ubuntu:latest

Step 2: Run an Ubuntu container
Create and start a new container named myubuntu, mapping host port 9090 to container port 80:
docker run -it -p 9090:80 --name myubuntu ubuntu:latest


Step 3: Update packages and install Nginx (and nano)
Inside the container, run:

apt update
apt install nginx nano -y

Step 4: Start Nginx and go to index.html
Start the Nginx service:

service nginx start

Go to the folder where the default Nginx page is stored:
cd /usr/share/nginx/html
ls

You will see index.html here.
Open index.html in nano editor:

nano index.html

Edit the file â€“ for example, change the <h1> line to:
<h1>Welcome user, I'm Neksha Srinivas!</h1>

Save and exit nano:
Press Ctrl + O â†’ Enter (to save)
Press Ctrl + X (to exit)

Step 5: View the page from browser (localhost)

On your Windows host, open a browser (Chrome/Edge) and go to:
http://localhost:9090

You should see your customized Nginx page:
Welcome user, I'm Neksha Srinivas!



Method 1: Image Creation Using docker commit

Step 1: Start a new container
docker run -it --name ubuntu-con-1 ubuntu:latest

Step 2: Make changes inside the container
apt update
apt install -y git

Step 3: Exit the container
exit

Step 4: Create image from container
docker commit ubuntu-con-1 img-commit-1

Step 5: Check images
docker images

Step 6 (optional): Tag and push
docker tag img-commit-1 triveni27/img-commit-1
docker push triveni27/img-commit-1

âœ… Method 2: Image Creation Using Dockerfile

Step 1: Create folder
mkdir image-creation
cd image-creation

Step 2: Create Dockerfile
notepad Dockerfile

Step 3: Add instructions in Dockerfile

FROM ubuntu:latest
RUN apt-get update && apt-get install -y git
CMD ["bash"]


Step 4: Build image
docker build -t img-dockerfile-1 .

Step 5: Test the image
docker run -it img-dockerfile-1

Step 6: Check images
docker images

Step 7 (optional): Tag and push
docker tag img-dockerfile-1 triveni27/img-dockerfile-1
docker push triveni27/img-dockerfile-1
